<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>US Passport Photo</title>
    
    <!-- PWA Meta Tags -->
    <meta name="description" content="AI-powered passport photo capture tool that helps you take perfect 2x2 inch US passport photos with real-time guidance and compliance checking.">
    <meta name="theme-color" content="#007AFF">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Passport Photo">
    <meta name="msapplication-TileColor" content="#007AFF">
    <meta name="msapplication-config" content="browserconfig.xml">
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="manifest.json">
    
    <!-- Apple Touch Icons -->
    <link rel="apple-touch-icon" sizes="152x152" href="icons/icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="icons/icon-192x192.png">
    
    <!-- Standard Icons -->
    <link rel="icon" type="image/png" sizes="32x32" href="icons/icon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/icon-16x16.png">
    <link rel="shortcut icon" href="icons/icon-192x192.png">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
        background: #000;
        color: #fff;
        overflow: hidden;
        position: fixed;
        width: 100%;
        height: 100vh;
        touch-action: none;
    }

    /* Loading State */
    .loading-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: #000;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 200;
        transition: opacity 0.5s ease;
    }

    .loading-overlay.hidden {
        opacity: 0;
        pointer-events: none;
    }

    .loading-spinner {
        width: 60px;
        height: 60px;
        border: 3px solid rgba(255,255,255,0.1);
        border-top: 3px solid #fff;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin-bottom: 20px;
    }

    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }

    /* Header - Simplified */
    .header {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        padding: 20px;
        background: linear-gradient(to bottom, rgba(0,0,0,0.9), transparent);
        z-index: 10;
        text-align: center;
    }

    .header-title {
        font-size: 20px;
        font-weight: 600;
        letter-spacing: 0.5px;
    }

    /* Camera Container */
    .camera-container {
        position: relative;
        width: 100%;
        height: 100vh;
        overflow: hidden;
        background: #000;
    }

    #video {
        width: 100%;
        height: 100%;
        object-fit: cover;
        -webkit-transform: scaleX(-1);
        transform: scaleX(-1);
    }

    /* Canvas Overlay */
    #overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
    }

    /* Positioning Status */
    .position-status {
        position: absolute;
        top: 80px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0,0,0,0.8);
        padding: 12px 24px;
        border-radius: 25px;
        font-size: 16px;
        font-weight: 500;
        transition: all 0.3s ease;
        z-index: 15;
    }

    .position-status.good {
        background: rgba(76, 217, 100, 0.9);
        color: #000;
    }

    .position-status.adjust {
        background: rgba(255, 204, 0, 0.9);
        color: #000;
    }

    /* Controls */
    .controls {
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        padding: 40px 20px;
        padding-bottom: max(40px, env(safe-area-inset-bottom));
        background: linear-gradient(to top, rgba(0,0,0,0.9), transparent);
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 40px;
    }

    /* Help Button */
    .help-btn {
        width: 50px;
        height: 50px;
        border-radius: 50%;
        border: 2px solid rgba(255,255,255,0.3);
        background: rgba(255,255,255,0.1);
        color: #fff;
        font-size: 24px;
        cursor: pointer;
        transition: all 0.2s;
        -webkit-tap-highlight-color: transparent;
    }

    .help-btn:active {
        transform: scale(0.9);
        background: rgba(255,255,255,0.2);
    }

    /* Capture Button */
    .capture-btn {
        width: 90px;
        height: 90px;
        border-radius: 50%;
        border: 5px solid #fff;
        background: rgba(255,255,255,0.2);
        cursor: pointer;
        transition: all 0.2s;
        position: relative;
        -webkit-tap-highlight-color: transparent;
    }

    .capture-btn:active {
        transform: scale(0.9);
    }

    .capture-btn::after {
        content: '';
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 70px;
        height: 70px;
        border-radius: 50%;
        background: #fff;
        transition: all 0.2s;
    }

    .capture-btn.capturing::after {
        width: 50px;
        height: 50px;
        background: #ff3b30;
    }
    
    .capture-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }

    /* Flash Animation */
    .flash {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(255,255,255,0.9);
        z-index: 150;
        opacity: 0;
        pointer-events: none;
    }

    .flash.active {
        animation: flashAnimation 0.5s ease-out;
    }

    @keyframes flashAnimation {
        0% { opacity: 0; }
        50% { opacity: 1; }
        100% { opacity: 0; }
    }

    /* Help Overlay */
    .help-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0,0,0,0.95);
        display: none;
        z-index: 100;
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
    }

    .help-overlay.active {
        display: block;
    }

    .help-content {
        padding: 80px 20px 40px;
        max-width: 500px;
        margin: 0 auto;
    }

    .help-close {
        position: fixed;
        top: 20px;
        right: 20px;
        width: 40px;
        height: 40px;
        background: rgba(255,255,255,0.1);
        border: none;
        border-radius: 50%;
        color: #fff;
        font-size: 24px;
        cursor: pointer;
        z-index: 101;
    }

    .help-section {
        margin-bottom: 40px;
    }

    .help-section h3 {
        font-size: 24px;
        margin-bottom: 15px;
        color: #007AFF;
    }

    .help-section p {
        font-size: 18px;
        line-height: 1.6;
        opacity: 0.9;
        margin-bottom: 10px;
    }

    .help-visual {
        background: rgba(255,255,255,0.05);
        border-radius: 20px;
        padding: 30px;
        margin: 20px 0;
        text-align: center;
    }

    .sample-position {
        width: 120px;
        height: 150px;
        margin: 0 auto 20px;
        border: 3px dashed rgba(76, 217, 100, 0.5);
        border-radius: 10px;
        position: relative;
    }

    .sample-head {
        position: absolute;
        top: 15%;
        left: 50%;
        transform: translateX(-50%);
        width: 60px;
        height: 60px;
        background: rgba(255,255,255,0.2);
        border-radius: 50%;
    }

    /* Preview Modal */
    .preview-modal {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: #000;
        display: none;
        flex-direction: column;
        z-index: 100;
    }

    .preview-modal.active {
        display: flex;
    }

    .preview-header {
        padding: 20px;
        text-align: center;
        background: rgba(0,0,0,0.5);
    }

    .preview-header h3 {
        font-size: 20px;
        font-weight: 500;
    }

    .preview-content {
        flex: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 20px;
    }

    .preview-content img {
        max-width: 100%;
        max-height: 100%;
        border-radius: 12px;
        box-shadow: 0 10px 40px rgba(0,0,0,0.5);
    }

    .preview-actions {
        padding: 30px 20px;
        padding-bottom: max(30px, env(safe-area-inset-bottom));
        display: flex;
        gap: 15px;
        background: rgba(0,0,0,0.5);
    }

    .btn {
        flex: 1;
        padding: 18px;
        border: none;
        border-radius: 30px;
        font-size: 18px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s;
        -webkit-tap-highlight-color: transparent;
    }

    .btn-primary {
        background: #007AFF;
        color: #fff;
    }

    .btn-secondary {
        background: rgba(255,255,255,0.2);
        color: #fff;
        backdrop-filter: blur(10px);
    }

    .btn:active {
        transform: scale(0.95);
    }

    /* Error State */
    .error-container {
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        height: 100%;
        padding: 40px 20px;
        text-align: center;
    }

    .error-icon {
        font-size: 80px;
        margin-bottom: 30px;
    }

    .error-container h2 {
        font-size: 28px;
        margin-bottom: 20px;
        color: #ff3b30;
    }

    .error-container p {
        font-size: 18px;
        line-height: 1.5;
        opacity: 0.8;
        margin-bottom: 30px;
        max-width: 400px;
    }

    /* First Time Overlay */
    .onboarding-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0,0,0,0.9);
        display: none;
        justify-content: center;
        align-items: center;
        z-index: 190;
        padding: 20px;
    }

    .onboarding-overlay.active {
        display: flex;
    }

    .onboarding-content {
        background: rgba(255,255,255,0.1);
        border-radius: 30px;
        padding: 40px 30px;
        max-width: 380px;
        text-align: center;
        backdrop-filter: blur(20px);
    }

    .onboarding-content h2 {
        font-size: 28px;
        margin-bottom: 20px;
    }

    .onboarding-content p {
        font-size: 18px;
        line-height: 1.5;
        opacity: 0.9;
        margin-bottom: 30px;
    }

    .onboarding-visual {
        margin: 30px 0;
    }

    /* Accessibility */
    @media (prefers-reduced-motion: reduce) {
        * {
            animation-duration: 0.01ms !important;
            animation-iteration-count: 1 !important;
            transition-duration: 0.01ms !important;
        }
    }

    /* Settings Button */
    .settings-btn {
        width: 50px;
        height: 50px;
        border-radius: 50%;
        border: 2px solid rgba(255,255,255,0.3);
        background: rgba(255,255,255,0.1);
        color: #fff;
        font-size: 24px;
        cursor: pointer;
        transition: all 0.2s;
        -webkit-tap-highlight-color: transparent;
    }

    .settings-btn:active {
        transform: scale(0.9);
        background: rgba(255,255,255,0.2);
    }

    /* Settings Modal */
    .settings-modal {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0,0,0,0.95);
        display: none;
        z-index: 100;
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
    }

    .settings-modal.active {
        display: block;
    }

    .settings-content {
        padding: 80px 20px;
        padding-bottom: max(80px, env(safe-area-inset-bottom) + 40px);
        max-width: 500px;
        margin: 0 auto;
        min-height: 100vh;
        box-sizing: border-box;
    }

    .settings-close {
        position: fixed;
        top: 20px;
        right: 20px;
        width: 40px;
        height: 40px;
        background: rgba(255,255,255,0.1);
        border: none;
        border-radius: 50%;
        color: #fff;
        font-size: 24px;
        cursor: pointer;
        z-index: 101;
    }

    .settings-section {
        margin-bottom: 25px;
    }

    .settings-section h3 {
        font-size: 18px;
        margin-bottom: 12px;
        color: #007AFF;
    }
    
    /* Compact layout for mobile */
    @media (max-height: 700px) {
        .settings-content {
            padding-top: 60px;
        }
        
        .settings-section {
            margin-bottom: 20px;
        }
        
        .settings-section h3 {
            font-size: 16px;
            margin-bottom: 10px;
        }
        
        .settings-input {
            padding: 10px 14px;
            font-size: 15px;
        }
        
        .settings-hint {
            font-size: 13px;
            margin-top: 6px;
        }
    }

    .settings-label {
        display: block;
        margin-bottom: 8px;
        font-size: 16px;
        opacity: 0.9;
    }

    .settings-input {
        width: 100%;
        padding: 12px 16px;
        border: 2px solid rgba(255,255,255,0.2);
        border-radius: 12px;
        background: rgba(255,255,255,0.1);
        color: #fff;
        font-size: 16px;
        transition: all 0.2s;
    }

    .settings-input:focus {
        outline: none;
        border-color: #007AFF;
        background: rgba(255,255,255,0.15);
    }

    .settings-hint {
        margin-top: 8px;
        font-size: 14px;
        opacity: 0.7;
    }

    .ai-status-indicator {
        display: inline-block;
        width: 8px;
        height: 8px;
        border-radius: 50%;
        margin-right: 6px;
        background: #ff3b30;
    }

    .ai-status-indicator.active {
        background: #4CD964;
    }

    /* AI Feedback Overlay */
    .ai-feedback {
        position: absolute;
        top: 140px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0,0,0,0.9);
        padding: 16px 24px;
        border-radius: 20px;
        font-size: 15px;
        max-width: 80%;
        text-align: center;
        transition: all 0.3s ease;
        opacity: 0;
        pointer-events: none;
        z-index: 15;
    }

    .ai-feedback.active {
        opacity: 1;
    }
</style>

</head>
<body>
    <!-- Loading Overlay -->
    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-spinner"></div>
        <p style="font-size: 18px; opacity: 0.8;">Initializing Camera...</p>
        <button onclick="skipLoading()" class="btn btn-secondary" style="margin-top: 30px; opacity: 0; transition: opacity 0.5s;" id="skipLoadingBtn">
            Skip
        </button>
    </div>

<!-- Flash Effect -->
<div class="flash" id="flash"></div>

<!-- Header -->
<div class="header">
    <div class="header-title">US Passport Photo</div>
    <div id="aiStatus" style="font-size: 12px; opacity: 0.6; margin-top: 5px;"></div>
</div>

<!-- Position Status -->
<div class="position-status adjust" id="positionStatus">
    Align your face with the guides
</div>

<!-- Camera Container -->
<div class="camera-container" id="cameraContainer">
    <video id="video" autoplay playsinline></video>
    <canvas id="overlay"></canvas>
</div>

<!-- Controls -->
<div class="controls">
    <button class="help-btn" onclick="showHelp()" aria-label="Help">?</button>
    <button class="capture-btn" id="captureBtn" onclick="capturePhoto()" aria-label="Capture photo"></button>
    <button class="settings-btn" onclick="showSettings()" aria-label="Settings">‚öôÔ∏è</button>
</div>

<!-- Help Overlay -->
<div class="help-overlay" id="helpOverlay">
    <button class="help-close" onclick="hideHelp()" aria-label="Close help">√ó</button>
    <div class="help-content">
        <div class="help-section">
            <h3>üì∑ How to Take Your Photo</h3>
            <div class="help-visual">
                <div class="sample-position">
                    <div class="sample-head"></div>
                </div>
                <p style="font-size: 16px; opacity: 0.7;">Position your head within the frame</p>
            </div>
            <p>1. <strong>Center your face</strong> in the square frame</p>
            <p>2. <strong>Align your eyes</strong> with the middle line</p>
            <p>3. <strong>Keep your head straight</strong> and look directly at camera</p>
            <p>4. The AI will analyze your position and provide real-time feedback</p>
            <p>5. Status turns <strong style="color: #4CD964;">green</strong> when photo is passport-compliant</p>
        </div>

        <div class="help-section">
            <h3>‚úÖ Passport Requirements</h3>
            <p>‚Ä¢ <strong>Neutral expression</strong> (no smiling)</p>
            <p>‚Ä¢ <strong>Both eyes open</strong> and visible</p>
            <p>‚Ä¢ <strong>No glasses</strong> if possible</p>
            <p>‚Ä¢ <strong>Plain background</strong> (white or off-white)</p>
            <p>‚Ä¢ <strong>No shadows</strong> on face or background</p>
            <p>‚Ä¢ <strong>Good lighting</strong> - face evenly lit</p>
        </div>

        <div class="help-section">
            <h3>üí° Tips for Best Results</h3>
            <p>‚Ä¢ Use <strong>natural lighting</strong> or face a window</p>
            <p>‚Ä¢ Keep phone at <strong>eye level</strong></p>
            <p>‚Ä¢ Stand about <strong>arm's length</strong> from camera</p>
            <p>‚Ä¢ Photo will be cropped to <strong>2√ó2 inches</strong></p>
        </div>

        <div class="help-section">
            <h3>‚ú® AI-Powered Features</h3>
            <p>‚Ä¢ <strong>Real-time analysis</strong> every 3 seconds</p>
            <p>‚Ä¢ <strong>Instant feedback</strong> on photo compliance</p>
            <p>‚Ä¢ <strong>Smart suggestions</strong> for improvements</p>
            <p>‚Ä¢ <strong>Background check</strong> for plain white requirement</p>
            <p>‚Ä¢ <strong>Expression detection</strong> for neutral face</p>
        </div>
    </div>
</div>

<!-- AI Feedback -->
<div class="ai-feedback" id="aiFeedback">
    <div id="aiFeedbackText"></div>
</div>

<!-- Preview Modal -->
<div class="preview-modal" id="previewModal">
    <div class="preview-header">
        <h3>Your Passport Photo</h3>
        <p style="opacity: 0.7; margin-top: 5px;">2√ó2 inches (600√ó600px)</p>
    </div>
    <div class="preview-content">
        <img id="previewImage" src="" alt="Captured passport photo">
    </div>
    <div class="preview-actions">
        <button class="btn btn-secondary" onclick="closePreview()">Retake</button>
        <button class="btn btn-primary" onclick="downloadPhoto()">Save Photo</button>
    </div>
</div>

<!-- First Time Onboarding -->
<div class="onboarding-overlay" id="onboardingOverlay">
    <div class="onboarding-content">
        <h2>üëã Welcome!</h2>
        <p>Let's take your US passport photo in seconds with AI assistance.</p>
        <div class="onboarding-visual">
            <div class="sample-position" style="margin: 0 auto;">
                <div class="sample-head"></div>
            </div>
        </div>
        <p>Position your face within the guides and our AI will help you capture a perfect 2√ó2 inch passport photo.</p>
        <button class="btn btn-primary" style="width: 100%;" onclick="startApp()">Get Started</button>
    </div>
</div>

<!-- Settings Modal -->
<div class="settings-modal" id="settingsModal">
    <button class="settings-close" onclick="hideSettings()" aria-label="Close settings">√ó</button>
    <div class="settings-content">
        <div class="settings-section">
            <h3>ü§ñ AI Configuration</h3>
            <label class="settings-label" for="apiEndpoint">API Endpoint</label>
            <input 
                type="url" 
                id="apiEndpoint" 
                class="settings-input" 
                placeholder="https://api.openai.com/v1"
                value="https://api.openai.com/v1"
            >
            <p class="settings-hint">Enter your OpenAI-compatible API endpoint</p>
        </div>

        <div class="settings-section">
            <label class="settings-label" for="apiKey">API Key</label>
            <input 
                type="password" 
                id="apiKey" 
                class="settings-input" 
                placeholder="sk-..."
            >
            <p class="settings-hint">Your API key is stored locally and never sent to our servers</p>
        </div>

        <div class="settings-section">
            <label class="settings-label" for="aiModel">Model</label>
            <input 
                type="text" 
                id="aiModel" 
                class="settings-input" 
                placeholder="gpt-4o-mini"
                value="gpt-4o-mini"
            >
            <p class="settings-hint">Model name (e.g., gpt-4o-mini, gpt-4-turbo)</p>
        </div>

        <div class="settings-section">
            <h3>üìä AI Status</h3>
            <p style="font-size: 16px;">
                <span class="ai-status-indicator" id="aiStatusIndicator"></span>
                <span id="aiStatusText">Not configured</span>
            </p>
            <button class="btn btn-primary" style="margin-top: 15px;" onclick="testAIConnection()">Test Connection</button>
        </div>

        <div class="settings-section">
            <button class="btn btn-primary" style="width: 100%;" onclick="saveSettings()">Save Settings</button>
        </div>
    </div>
</div>

<script>
    // Global variables
    let video = document.getElementById('video');
    let canvas = document.getElementById('overlay');
    let ctx = canvas.getContext('2d');
    let stream = null;
    let capturedImageData = null;
    let isFirstTime = !localStorage.getItem('passportPhotoAppUsed');
    
    // Camera permission state management
    let cameraPermissionState = 'unknown'; // 'unknown', 'granted', 'denied', 'requesting'
    let cameraInitialized = false;
    let cameraInitAttempts = 0;
    const MAX_CAMERA_ATTEMPTS = 2;

    // US Passport photo specifications
    const PASSPORT_GUIDES = {
        headTop: 15,      // Top of head position
        eyeLevel: 35,     // Eye level position
        chinLine: 60,     // Chin position
        opacity: 0.8
    };

    // Passport photo dimensions (2x2 inches at 300 DPI)
    const PASSPORT_SIZE = 600; // pixels

    // Prevent mobile browser behaviors
    document.addEventListener('touchmove', function(e) {
        if (e.target.closest('.help-overlay')) return;
        e.preventDefault();
    }, { passive: false });

    document.addEventListener('gesturestart', function(e) {
        e.preventDefault();
    });

    // Check first time and initialize
    function checkFirstTime() {
        console.log('Checking first time user...');
        if (isFirstTime) {
            console.log('First time user - showing onboarding');
            document.getElementById('onboardingOverlay').classList.add('active');
            // Still initialize camera in background
            initCamera();
        } else {
            console.log('Returning user - initializing camera directly');
            initCamera();
        }
    }

    // Start app after onboarding
    function startApp() {
        console.log('Starting app after onboarding...');
        localStorage.setItem('passportPhotoAppUsed', 'true');
        document.getElementById('onboardingOverlay').classList.remove('active');
        // Camera should already be initialized
        
        // If loading is still showing, hide it
        setTimeout(() => {
            const loadingOverlay = document.getElementById('loadingOverlay');
            if (!loadingOverlay.classList.contains('hidden')) {
                loadingOverlay.classList.add('hidden');
            }
        }, 500);
    }

    // Initialize camera
    async function initCamera() {
        // Prevent multiple simultaneous initialization attempts
        if (cameraInitialized || cameraPermissionState === 'requesting') {
            console.log('Camera already initialized or being initialized...');
            return;
        }
        
        // Check if we've exceeded max attempts
        if (cameraInitAttempts >= MAX_CAMERA_ATTEMPTS) {
            console.log('Max camera init attempts reached, showing demo mode...');
            showDemoMode();
            return;
        }
        
        cameraInitAttempts++;
        cameraPermissionState = 'requesting';
        console.log(`Initializing camera... (attempt ${cameraInitAttempts}/${MAX_CAMERA_ATTEMPTS})`);
        
        try {
            // Check if we're in a secure context
            if (!window.isSecureContext) {
                throw new Error('Camera requires HTTPS or localhost. Please use a local server or upload to a web host.');
            }

            // Check if getUserMedia is available
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                throw new Error('Camera API not supported in this browser.');
            }

            // Check existing permission state first
            try {
                const permissionStatus = await navigator.permissions.query({ name: 'camera' });
                console.log('Camera permission status:', permissionStatus.state);
                
                if (permissionStatus.state === 'denied') {
                    cameraPermissionState = 'denied';
                    throw new Error('Camera permission was previously denied');
                }
            } catch (permError) {
                console.log('Permission API not available, proceeding with getUserMedia...');
            }

            console.log('Requesting camera permissions...');

            // Get the right camera based on device
            const constraints = { 
                video: { 
                    facingMode: 'user',
                    width: { ideal: 1920 },
                    height: { ideal: 1920 },
                    aspectRatio: { ideal: 1 }
                } 
            };

            // Try to get user media with ideal constraints
            try {
                stream = await navigator.mediaDevices.getUserMedia(constraints);
                console.log('Camera access granted with ideal constraints');
            } catch (err) {
                console.log('Ideal constraints failed, trying basic constraints...');
                // Fallback to basic constraints if ideal ones fail
                try {
                    stream = await navigator.mediaDevices.getUserMedia({ 
                        video: { facingMode: 'user' } 
                    });
                    console.log('Camera access granted with basic constraints');
                } catch (fallbackErr) {
                    console.log('Basic constraints also failed, trying any video...');
                    // Last resort - try any video input
                    stream = await navigator.mediaDevices.getUserMedia({ video: true });
                }
            }

            console.log('Setting video stream...');
            video.srcObject = stream;
            
            // Mark camera as successfully initialized
            cameraPermissionState = 'granted';
            cameraInitialized = true;
            
            // Ensure video plays
            video.play().catch(err => {
                console.error('Video play failed:', err);
            });
            
            // Handle orientation changes
            handleOrientationChange();
            window.addEventListener('orientationchange', handleOrientationChange);
            window.addEventListener('resize', handleOrientationChange);
            
            // Multiple event listeners for reliability
            let initialized = false;
            
            const initializeVideo = () => {
                if (initialized) return;
                initialized = true;
                
                console.log('Video initialized successfully');
                resizeCanvas();
                drawOverlay();
                // Hide loading overlay
                setTimeout(() => {
                    document.getElementById('loadingOverlay').classList.add('hidden');
                }, 500);
            };
            
            // Wait for various video events
            video.addEventListener('loadedmetadata', initializeVideo);
            video.addEventListener('loadeddata', initializeVideo);
            video.addEventListener('canplay', initializeVideo);
            
            // Also check if video is already ready
            if (video.readyState >= 2) {
                initializeVideo();
            }

            // Add timeout in case events don't fire
            setTimeout(() => {
                if (!initialized) {
                    console.warn('Video initialization timeout - forcing initialization');
                    initializeVideo();
                }
            }, 3000);

        } catch (err) {
            console.error('Error accessing camera:', err);
            
            // Update permission state based on error type
            if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') {
                cameraPermissionState = 'denied';
            } else {
                cameraPermissionState = 'unknown';
            }
            
            showErrorMessage(err);
            document.getElementById('loadingOverlay').classList.add('hidden');
        }
    }

    // Handle device orientation
    function handleOrientationChange() {
        setTimeout(() => {
            if (video.srcObject) {
                resizeCanvas();
            }
        }, 500);
    }

    // Show detailed error message
    function showErrorMessage(err) {
        let message = '';
        let solution = '';
        let showPermissionButton = false;

        if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') {
            message = 'Camera permission needed';
            solution = 'This app needs camera access to take passport photos.';
            showPermissionButton = (cameraPermissionState !== 'denied');
        } else if (err.name === 'NotFoundError' || err.name === 'DevicesNotFoundError') {
            message = 'No camera detected';
            solution = 'Please connect a camera to continue.';
        } else if (err.name === 'NotReadableError' || err.name === 'TrackStartError') {
            message = 'Camera is in use';
            solution = 'Please close other apps using the camera and try again.';
        } else if (err.message && err.message.includes('secure context')) {
            message = 'Secure connection required';
            solution = 'Please use HTTPS or a local server:\n\n‚Ä¢ Python: python -m http.server 8000\n‚Ä¢ VS Code: Live Server extension\n‚Ä¢ Node.js: npx http-server';
        } else {
            message = 'Camera unavailable';
            solution = err.message || 'Please check your camera and try again.';
        }

        // Display error in the camera container
        const container = document.getElementById('cameraContainer');
        container.innerHTML = `
            <div class="error-container">
                <div class="error-icon">üìµ</div>
                <h2>${message}</h2>
                <p style="white-space: pre-line;">${solution}</p>
                ${showPermissionButton ? `
                    <button onclick="requestCameraPermission()" class="btn btn-primary" style="margin-bottom: 15px;">
                        Request Camera Access
                    </button>
                ` : ''}
                <button onclick="location.reload()" class="btn btn-secondary">
                    Refresh Page
                </button>
            </div>
        `;
    }

    // Manually request camera permission
    async function requestCameraPermission() {
        // Prevent multiple permission requests
        if (cameraPermissionState === 'requesting') {
            console.log('Permission request already in progress...');
            return;
        }
        
        // If already denied, show settings instructions instead of requesting again
        if (cameraPermissionState === 'denied') {
            showPermissionInstructions();
            return;
        }
        
        const loadingOverlay = document.getElementById('loadingOverlay');
        loadingOverlay.classList.remove('hidden');
        cameraPermissionState = 'requesting';
        
        try {
            // This will trigger the permission prompt
            const stream = await navigator.mediaDevices.getUserMedia({ video: true });
            // If successful, clean up and reinitialize
            stream.getTracks().forEach(track => track.stop());
            
            // Reset state and try initialization again
            cameraPermissionState = 'unknown';
            cameraInitialized = false;
            cameraInitAttempts = 0;
            
            // Reinitialize camera
            initCamera();
            
        } catch (err) {
            console.error('Permission request failed:', err);
            cameraPermissionState = 'denied';
            loadingOverlay.classList.add('hidden');
            
            // Show instructions instead of repeated prompts
            showPermissionInstructions();
        }
    }
    
    // Show permission instructions instead of repeated prompts
    function showPermissionInstructions() {
        const container = document.getElementById('cameraContainer');
        container.innerHTML = `
            <div class="error-container">
                <div class="error-icon">üîí</div>
                <h2>Camera Access Required</h2>
                <p>To use this app, please enable camera access in your browser:</p>
                <div style="text-align: left; max-width: 400px; margin: 20px auto;">
                    <p><strong>Chrome/Edge:</strong><br>
                    ‚Ä¢ Click the camera icon in the address bar<br>
                    ‚Ä¢ Select "Always allow" for this site</p>
                    
                    <p><strong>Safari:</strong><br>
                    ‚Ä¢ Go to Settings ‚Üí Safari ‚Üí Camera<br>
                    ‚Ä¢ Set to "Allow" for this site</p>
                    
                    <p><strong>Firefox:</strong><br>
                    ‚Ä¢ Click the lock icon in address bar<br>
                    ‚Ä¢ Enable camera permissions</p>
                </div>
                <button onclick="location.reload()" class="btn btn-primary">
                    Refresh After Enabling
                </button>
                <button onclick="showDemoMode()" class="btn btn-secondary" style="margin-top: 10px;">
                    Use Demo Mode Instead
                </button>
            </div>
        `;
    }

    // Resize canvas to match video
    function resizeCanvas() {
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        
        // Match canvas display size to video
        const rect = video.getBoundingClientRect();
        canvas.style.width = rect.width + 'px';
        canvas.style.height = rect.height + 'px';
    }

    // Draw overlay guides for US passport photos
    function drawOverlay() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        const width = canvas.width;
        const height = canvas.height;
        
        // Calculate the square crop area (centered)
        const cropSize = Math.min(width, height) * 0.7;
        const cropX = (width - cropSize) / 2;
        const cropY = (height - cropSize) / 2;
        
        // Darken area outside crop
        ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
        ctx.fillRect(0, 0, width, height);
        
        // Clear the crop area
        ctx.clearRect(cropX, cropY, cropSize, cropSize);
        
        // Draw crop frame with corners
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 3;
        const cornerLength = 30;
        
        // Top-left corner
        ctx.beginPath();
        ctx.moveTo(cropX, cropY + cornerLength);
        ctx.lineTo(cropX, cropY);
        ctx.lineTo(cropX + cornerLength, cropY);
        ctx.stroke();
        
        // Top-right corner
        ctx.beginPath();
        ctx.moveTo(cropX + cropSize - cornerLength, cropY);
        ctx.lineTo(cropX + cropSize, cropY);
        ctx.lineTo(cropX + cropSize, cropY + cornerLength);
        ctx.stroke();
        
        // Bottom-left corner
        ctx.beginPath();
        ctx.moveTo(cropX, cropY + cropSize - cornerLength);
        ctx.lineTo(cropX, cropY + cropSize);
        ctx.lineTo(cropX + cornerLength, cropY + cropSize);
        ctx.stroke();
        
        // Bottom-right corner
        ctx.beginPath();
        ctx.moveTo(cropX + cropSize - cornerLength, cropY + cropSize);
        ctx.lineTo(cropX + cropSize, cropY + cropSize);
        ctx.lineTo(cropX + cropSize, cropY + cropSize - cornerLength);
        ctx.stroke();
        
        // Calculate guide positions within crop
        const eyeLevelY = cropY + (cropSize * (PASSPORT_GUIDES.eyeLevel / 100));
        
        // Draw eye level guide (main guide)
        ctx.strokeStyle = '#4CD964';
        ctx.lineWidth = 5;
        ctx.setLineDash([30, 15]);
        ctx.beginPath();
        ctx.moveTo(cropX + 20, eyeLevelY);
        ctx.lineTo(cropX + cropSize - 20, eyeLevelY);
        ctx.stroke();
        
        // Draw center line
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.lineWidth = 1;
        ctx.setLineDash([10, 10]);
        ctx.beginPath();
        ctx.moveTo(cropX + cropSize / 2, cropY + 20);
        ctx.lineTo(cropX + cropSize / 2, cropY + cropSize - 20);
        ctx.stroke();
        
        // Draw floating labels
        ctx.setLineDash([]);
        
        // Eye level label with background
        const eyeLabel = 'ALIGN EYES HERE';
        ctx.font = 'bold 24px Arial';
        const eyeMetrics = ctx.measureText(eyeLabel);
        const eyeLabelX = cropX + (cropSize - eyeMetrics.width) / 2;
        const eyeLabelY = eyeLevelY - 30;
        
        // Label background
        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        ctx.fillRect(eyeLabelX - 15, eyeLabelY - 28, eyeMetrics.width + 30, 40);
        
        // Label text
        ctx.fillStyle = '#4CD964';
        ctx.fillText(eyeLabel, eyeLabelX, eyeLabelY);
        
        // Photo size indicator
        ctx.font = '16px Arial';
        ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
        const sizeLabel = '2√ó2 inch';
        const sizeMetrics = ctx.measureText(sizeLabel);
        ctx.fillText(sizeLabel, cropX + (cropSize - sizeMetrics.width) / 2, cropY - 10);
        
        // Start AI monitoring if configured
        if (aiConfig.apiKey && !aiMonitoringInterval) {
            startAIMonitoring();
        }
        
        requestAnimationFrame(drawOverlay);
    }

    // Show help
    function showHelp() {
        document.getElementById('helpOverlay').classList.add('active');
    }

    // Hide help
    function hideHelp() {
        document.getElementById('helpOverlay').classList.remove('active');
    }

    // Capture photo with animation
    function capturePhoto() {
        // Visual feedback
        const captureBtn = document.getElementById('captureBtn');
        captureBtn.classList.add('capturing');
        
        // Flash effect
        const flash = document.getElementById('flash');
        flash.classList.add('active');
        
        // Haptic feedback if available
        if (navigator.vibrate) {
            navigator.vibrate(50);
        }
        
        setTimeout(() => {
            // Create a square capture area for passport photo
            const videoWidth = video.videoWidth;
            const videoHeight = video.videoHeight;
            
            // Calculate the square crop area (centered)
            const size = Math.min(videoWidth, videoHeight) * 0.7;
            const startX = (videoWidth - size) / 2;
            const startY = (videoHeight - size) / 2;
            
            // Create canvas for cropped passport photo
            const captureCanvas = document.createElement('canvas');
            captureCanvas.width = PASSPORT_SIZE;
            captureCanvas.height = PASSPORT_SIZE;
            const captureCtx = captureCanvas.getContext('2d');
            
            // Fill with white background (passport requirement)
            captureCtx.fillStyle = '#FFFFFF';
            captureCtx.fillRect(0, 0, PASSPORT_SIZE, PASSPORT_SIZE);
            
            // Draw the cropped and scaled video frame (mirror back for capture)
            captureCtx.save();
            captureCtx.scale(-1, 1);
            captureCtx.drawImage(
                video, 
                startX, startY, size, size,  // Source rectangle
                -PASSPORT_SIZE, 0, PASSPORT_SIZE, PASSPORT_SIZE  // Destination (flipped)
            );
            captureCtx.restore();
            
            // Convert to blob with high quality
            captureCanvas.toBlob((blob) => {
                capturedImageData = URL.createObjectURL(blob);
                showPreview();
                
                // Reset button state
                captureBtn.classList.remove('capturing');
                flash.classList.remove('active');
                
                // AI analysis if configured
                if (aiConfig.apiKey) {
                    analyzePhotoWithAI(blob);
                }
            }, 'image/jpeg', 0.95);
        }, 200);
    }

    // Show preview modal
    function showPreview() {
        document.getElementById('previewImage').src = capturedImageData;
        document.getElementById('previewModal').classList.add('active');
    }

    // Close preview
    function closePreview() {
        document.getElementById('previewModal').classList.remove('active');
        if (capturedImageData) {
            URL.revokeObjectURL(capturedImageData);
            capturedImageData = null;
        }
    }

    // Download photo
    function downloadPhoto() {
        try {
            const link = document.createElement('a');
            link.href = capturedImageData;
            link.download = `passport_photo_${new Date().getTime()}.jpg`;
            
            // For PWA compatibility, add to document and trigger
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            // Show success feedback
            const status = document.getElementById('positionStatus');
            status.textContent = 'Photo saved!';
            status.className = 'position-status good';
            
            // Auto-close preview after success
            setTimeout(() => {
                closePreview();
                status.textContent = 'Align your face with the guides';
                status.className = 'position-status adjust';
            }, 1500);
            
        } catch (error) {
            console.error('Download failed:', error);
            
            // Fallback: Show image in new tab for manual save
            const newWindow = window.open();
            newWindow.document.write(`
                <html>
                    <head><title>Passport Photo</title></head>
                    <body style="margin:0;padding:20px;text-align:center;background:#f0f0f0;">
                        <h2>Right-click and "Save Image As..."</h2>
                        <img src="${capturedImageData}" style="max-width:100%;border:1px solid #ccc;"/>
                        <br><br>
                        <button onclick="window.close()" style="padding:10px 20px;font-size:16px;">Close</button>
                    </body>
                </html>
            `);
            
            // Show fallback message
            const status = document.getElementById('positionStatus');
            status.textContent = 'Photo opened in new tab - right-click to save';
            status.className = 'position-status adjust';
            
            setTimeout(() => {
                closePreview();
                status.textContent = 'Align your face with the guides';
                status.className = 'position-status adjust';
            }, 3000);
        }
    }

    // AI Configuration
    let aiConfig = {
        endpoint: localStorage.getItem('aiEndpoint') || 'https://api.openai.com/v1',
        apiKey: localStorage.getItem('aiApiKey') || '',
        model: localStorage.getItem('aiModel') || 'gpt-4o-mini'
    };
    let aiMonitoringInterval = null;

    // Settings Modal Functions
    function showSettings() {
        document.getElementById('settingsModal').classList.add('active');
        // Load current settings
        document.getElementById('apiEndpoint').value = aiConfig.endpoint;
        document.getElementById('apiKey').value = aiConfig.apiKey;
        document.getElementById('aiModel').value = aiConfig.model;
        updateAIStatus();
    }

    function hideSettings() {
        document.getElementById('settingsModal').classList.remove('active');
    }

    function saveSettings() {
        aiConfig.endpoint = document.getElementById('apiEndpoint').value;
        aiConfig.apiKey = document.getElementById('apiKey').value;
        aiConfig.model = document.getElementById('aiModel').value;
        
        // Save to localStorage
        localStorage.setItem('aiEndpoint', aiConfig.endpoint);
        localStorage.setItem('aiApiKey', aiConfig.apiKey);
        localStorage.setItem('aiModel', aiConfig.model);
        
        updateAIStatus();
        hideSettings();
        
        // Start AI monitoring if configured
        if (aiConfig.apiKey) {
            startAIMonitoring();
        }
    }

    function updateAIStatus() {
        const aiStatus = document.getElementById('aiStatus');
        const aiStatusText = document.getElementById('aiStatusText');
        const aiStatusIndicator = document.getElementById('aiStatusIndicator');
        
        if (aiConfig.apiKey) {
            aiStatus.textContent = '‚ú® AI-Powered Analysis Active';
            aiStatusText.textContent = 'Configured';
            aiStatusIndicator.classList.add('active');
        } else {
            aiStatus.textContent = 'Configure AI in Settings';
            aiStatusText.textContent = 'Not configured';
            aiStatusIndicator.classList.remove('active');
        }
    }

    async function testAIConnection() {
        const statusText = document.getElementById('aiStatusText');
        const statusIndicator = document.getElementById('aiStatusIndicator');
        
        // Get the current value from the input field
        const currentApiKey = document.getElementById('apiKey').value;
        const currentEndpoint = document.getElementById('apiEndpoint').value;
        const currentModel = document.getElementById('aiModel').value;
        
        if (!currentApiKey) {
            alert('Please enter an API key first');
            return;
        }
        
        statusText.textContent = 'Testing connection...';
        
        try {
            // Use different token parameter based on model
            const tokenParam = currentModel.includes('o3') || currentModel.includes('o1') 
                ? { max_completion_tokens: 5 }
                : { max_tokens: 5 };
            
            const response = await fetch(`${currentEndpoint}/chat/completions`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${currentApiKey}`
                },
                body: JSON.stringify({
                    model: currentModel,
                    messages: [{role: 'user', content: 'test'}],
                    ...tokenParam
                })
            });
            
            if (response.ok) {
                statusText.textContent = 'Connected successfully!';
                statusIndicator.classList.add('active');
                setTimeout(() => {
                    statusText.textContent = 'Configured';
                }, 2000);
            } else {
                const error = await response.json();
                statusText.textContent = 'Connection failed';
                statusIndicator.classList.remove('active');
                alert(`Connection failed: ${error.error?.message || 'Unknown error'}`);
            }
        } catch (error) {
            statusText.textContent = 'Connection failed';
            statusIndicator.classList.remove('active');
            alert(`Connection error: ${error.message}`);
        }
    }

    // AI Integration
    let isAnalyzing = false;
    let lastAnalysisTime = 0;
    const ANALYSIS_INTERVAL = 3000; // Analyze every 3 seconds

    async function analyzePhotoWithAI(photoBlob, isLiveAnalysis = false) {
        if (isAnalyzing) return;
        if (!aiConfig.apiKey) return;
        
        isAnalyzing = true;

        try {
            // Convert blob to base64
            const base64 = await blobToBase64(photoBlob);
            
            // Show analyzing status only for captured photos
            if (!isLiveAnalysis) {
                const status = document.getElementById('positionStatus');
                status.textContent = 'AI analyzing photo...';
                status.className = 'position-status adjust';
            }

            // Use OpenAI Vision API to analyze the photo
            const messages = [
                {
                    role: 'user',
                    content: [
                        {
                            type: 'text',
                            text: `You are a passport photo analyzer. Analyze this photo for US passport photo compliance.

Check for:
1. Face position and centering
2. Background (must be plain white/off-white)
3. Expression (must be neutral)
4. Eyes (both visible, no glare on glasses)
5. Lighting (even, no shadows)
6. Overall passport photo compliance

IMPORTANT: You MUST respond with ONLY a JSON object, no other text. Do not include markdown formatting or code blocks.

Return this exact JSON structure:
{
    "isCompliant": true or false,
    "status": "Good to go!" or "Needs adjustment",
    "mainIssue": "Brief main issue" or "None",
    "quickTips": ["Tip 1", "Tip 2"]
}

Rules:
- isCompliant: true if photo meets all requirements, false otherwise
- status: "Good to go!" if compliant, "Needs adjustment" if not
- mainIssue: The most important issue or "None" if compliant
- quickTips: Array of 0-2 brief action items (empty array if compliant)

Respond with valid JSON only. No explanations or other text.`
                        },
                        {
                            type: 'image_url',
                            image_url: {
                                url: base64
                            }
                        }
                    ]
                }
            ];

            // Use different parameters based on model
            const isO3OrO1 = aiConfig.model.includes('o3') || aiConfig.model.includes('o1');
            const tokenParam = isO3OrO1 
                ? { max_completion_tokens: 3000 }
                : { max_tokens: 3000 };
            
            // Build request body - o3/o1 models don't support temperature
            const requestBody = {
                model: aiConfig.model,
                messages: messages,
                ...tokenParam
            };
            
            // Only add temperature for models that support it
            if (!isO3OrO1) {
                requestBody.temperature = 0.1;
            }
            
            const response = await fetch(`${aiConfig.endpoint}/chat/completions`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${aiConfig.apiKey}`
                },
                body: JSON.stringify(requestBody)
            });
            
            if (!response.ok) {
                throw new Error(`API request failed: ${response.status}`);
            }
            
            const result = await response.json();
            const content = result.choices[0]?.message?.content;
            
            try {
                // Clean response and parse
                let cleanResponse = content.trim();
                
                // Check if response is an error message instead of JSON
                if (!cleanResponse.startsWith('{') && !cleanResponse.includes('```')) {
                    console.warn('AI returned non-JSON response:', cleanResponse);
                    if (!isLiveAnalysis) {
                        const status = document.getElementById('positionStatus');
                        status.textContent = 'AI analysis unavailable';
                        status.className = 'position-status adjust';
                    }
                    return;
                }
                
                // Remove markdown code blocks if present
                if (cleanResponse.startsWith('```json')) {
                    cleanResponse = cleanResponse.replace(/^```json\s*/, '').replace(/\s*```$/, '');
                } else if (cleanResponse.startsWith('```')) {
                    cleanResponse = cleanResponse.replace(/^```\s*/, '').replace(/\s*```$/, '');
                }
                
                const analysis = JSON.parse(cleanResponse.trim());
                displayAIFeedback(analysis, isLiveAnalysis);
            } catch (parseError) {
                console.error('Failed to parse AI response:', parseError, 'Response:', content);
                if (!isLiveAnalysis) {
                    const status = document.getElementById('positionStatus');
                    status.textContent = 'Ready to capture';
                    status.className = 'position-status adjust';
                }
            }

        } catch (error) {
            console.error('AI analysis error:', error);
            if (!isLiveAnalysis) {
                const status = document.getElementById('positionStatus');
                status.textContent = 'Ready to capture';
                status.className = 'position-status adjust';
            }
        } finally {
            isAnalyzing = false;
        }
    }

    // Convert blob to base64
    function blobToBase64(blob) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onloadend = () => resolve(reader.result);
            reader.onerror = reject;
            reader.readAsDataURL(blob);
        });
    }

    // Display AI feedback
    function displayAIFeedback(analysis, isLiveAnalysis = false) {
        const status = document.getElementById('positionStatus');
        const feedbackEl = document.getElementById('aiFeedback');
        const feedbackText = document.getElementById('aiFeedbackText');

        // Update status indicator
        status.textContent = analysis.status;
        status.className = analysis.isCompliant ? 'position-status good' : 'position-status adjust';

        // Show detailed feedback if there are issues
        if (!analysis.isCompliant && analysis.quickTips && analysis.quickTips.length > 0) {
            feedbackText.innerHTML = `
                <strong>${analysis.mainIssue}</strong><br>
                ${analysis.quickTips.map(tip => `‚Ä¢ ${tip}`).join('<br>')}
            `;
            feedbackEl.classList.add('active');

            // Hide after 5 seconds for live analysis, longer for captured photos
            setTimeout(() => {
                feedbackEl.classList.remove('active');
            }, isLiveAnalysis ? 5000 : 8000);
        } else if (analysis.isCompliant && !isLiveAnalysis) {
            // Show success for captured photos
            feedbackText.innerHTML = `<strong>‚úÖ Perfect passport photo!</strong>`;
            feedbackEl.classList.add('active');
            setTimeout(() => {
                feedbackEl.classList.remove('active');
            }, 3000);
        }
    }

    // Continuous AI monitoring
    function startAIMonitoring() {
        if (!aiConfig.apiKey) return;
        
        // Clear existing interval if any
        if (aiMonitoringInterval) {
            clearInterval(aiMonitoringInterval);
        }
        
        // Set up monitoring interval
        aiMonitoringInterval = setInterval(async () => {
            if (!video.srcObject || isAnalyzing) return;
            
            const now = Date.now();
            if (now - lastAnalysisTime < ANALYSIS_INTERVAL) {
                return; // Don't analyze too frequently
            }
            
            lastAnalysisTime = now;
            
            // Capture current frame
            const tempCanvas = document.createElement('canvas');
            const videoWidth = video.videoWidth;
            const videoHeight = video.videoHeight;
            
            if (!videoWidth || !videoHeight) return;
            
            // Use same crop logic as capture
            const size = Math.min(videoWidth, videoHeight) * 0.7;
            const startX = (videoWidth - size) / 2;
            const startY = (videoHeight - size) / 2;
            
            tempCanvas.width = 300; // Smaller size for analysis
            tempCanvas.height = 300;
            const tempCtx = tempCanvas.getContext('2d');
            
            // Fill with white background
            tempCtx.fillStyle = '#FFFFFF';
            tempCtx.fillRect(0, 0, 300, 300);
            
            // Draw cropped frame
            tempCtx.save();
            tempCtx.scale(-1, 1);
            tempCtx.drawImage(
                video, 
                startX, startY, size, size,
                -300, 0, 300, 300
            );
            tempCtx.restore();
            
            // Convert to blob and analyze
            tempCanvas.toBlob((blob) => {
                if (blob) {
                    analyzePhotoWithAI(blob, true);
                }
            }, 'image/jpeg', 0.8);
        }, ANALYSIS_INTERVAL);
    }

    // Initialize app
    window.addEventListener('load', () => {
        console.log('App loaded, checking first time...');
        
        // Check AI availability
        updateAIStatus();
        
        checkFirstTime();
        
        // Show skip button after 3 seconds if still loading
        setTimeout(() => {
            const skipBtn = document.getElementById('skipLoadingBtn');
            if (skipBtn && !document.getElementById('loadingOverlay').classList.contains('hidden')) {
                skipBtn.style.opacity = '1';
            }
        }, 3000);
        
        // Auto-skip loading after 10 seconds to prevent getting stuck
        setTimeout(() => {
            const loadingOverlay = document.getElementById('loadingOverlay');
            if (loadingOverlay && !loadingOverlay.classList.contains('hidden')) {
                console.log('Auto-skipping loading after timeout...');
                skipLoading();
            }
        }, 10000);
    });

    // Skip loading (emergency bypass)
    function skipLoading() {
        console.log('Skipping loading screen...');
        document.getElementById('loadingOverlay').classList.add('hidden');
        document.getElementById('onboardingOverlay').classList.remove('active');
        
        // Show error message with better UX
        const container = document.getElementById('cameraContainer');
        container.innerHTML = `
            <div class="error-container">
                <div class="error-icon">‚ö†Ô∏è</div>
                <h2>Camera initialization skipped</h2>
                <p>The camera may not be working properly.</p>
                <button onclick="location.reload()" class="btn btn-primary">
                    Try Again
                </button>
                <button onclick="requestCameraPermission()" class="btn btn-secondary" style="margin-top: 10px;">
                    Request Camera Access
                </button>
                <button onclick="showDemoMode()" class="btn btn-secondary" style="margin-top: 10px;">
                    Demo Mode (No Camera)
                </button>
            </div>
        `;
    }
    
    // Demo mode for testing without camera
    function showDemoMode() {
        console.log('Entering demo mode...');
        const container = document.getElementById('cameraContainer');
        container.innerHTML = `
            <div class="error-container">
                <div class="error-icon">üì∑</div>
                <h2>Demo Mode</h2>
                <p>Camera not available. You can still test the app interface.</p>
                <button onclick="simulateCapture()" class="btn btn-primary">
                    Simulate Photo Capture
                </button>
                <button onclick="location.reload()" class="btn btn-secondary" style="margin-top: 10px;">
                    Try Camera Again
                </button>
            </div>
        `;
    }
    
    // Simulate photo capture for demo
    function simulateCapture() {
        // Create a demo canvas with a simple pattern
        const canvas = document.createElement('canvas');
        canvas.width = 600;
        canvas.height = 600;
        const ctx = canvas.getContext('2d');
        
        // Draw a simple demo image
        ctx.fillStyle = '#f0f0f0';
        ctx.fillRect(0, 0, 600, 600);
        
        ctx.fillStyle = '#007AFF';
        ctx.font = 'bold 48px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('DEMO PHOTO', 300, 250);
        
        ctx.fillStyle = '#666';
        ctx.font = '24px Arial';
        ctx.fillText('2√ó2 inch passport photo', 300, 300);
        ctx.fillText('600√ó600 pixels', 300, 350);
        
        // Convert to blob and show preview
        canvas.toBlob((blob) => {
            capturedImageData = URL.createObjectURL(blob);
            showPreview();
        }, 'image/jpeg', 0.95);
    }

    // Enhanced UX: Keyboard and click-outside support
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
            // Close any open modals with ESC key
            const previewModal = document.getElementById('previewModal');
            const helpOverlay = document.getElementById('helpOverlay');
            const settingsModal = document.getElementById('settingsModal');
            
            if (previewModal && previewModal.classList.contains('active')) {
                closePreview();
            } else if (helpOverlay && helpOverlay.classList.contains('active')) {
                hideHelp();
            } else if (settingsModal && settingsModal.classList.contains('active')) {
                hideSettings();
            }
        }
    });
    
    // Click outside to close modals
    document.addEventListener('click', (e) => {
        const previewModal = document.getElementById('previewModal');
        const helpOverlay = document.getElementById('helpOverlay');
        const settingsModal = document.getElementById('settingsModal');
        
        // Close preview modal if clicking outside
        if (previewModal && previewModal.classList.contains('active') && e.target === previewModal) {
            closePreview();
        }
        
        // Close help overlay if clicking outside
        if (helpOverlay && helpOverlay.classList.contains('active') && e.target === helpOverlay) {
            hideHelp();
        }
        
        // Close settings modal if clicking outside
        if (settingsModal && settingsModal.classList.contains('active') && e.target === settingsModal) {
            hideSettings();
        }
    });

    // Debug: Log any errors
    window.addEventListener('error', (e) => {
        console.error('Global error:', e.error);
    });

    window.addEventListener('unhandledrejection', (e) => {
        console.error('Unhandled promise rejection:', e.reason);
    });

    // PWA Service Worker Registration
    if ('serviceWorker' in navigator) {
        window.addEventListener('load', async () => {
            try {
                console.log('Registering service worker...');
                const registration = await navigator.serviceWorker.register('/sw.js');
                console.log('Service Worker registered successfully:', registration);
                
                // Handle service worker updates
                registration.addEventListener('updatefound', () => {
                    const newWorker = registration.installing;
                    if (newWorker) {
                        newWorker.addEventListener('statechange', () => {
                            if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                // New service worker is available
                                console.log('New service worker available');
                                showUpdateNotification();
                            }
                        });
                    }
                });
                
                // Listen for service worker messages
                navigator.serviceWorker.addEventListener('message', (event) => {
                    if (event.data && event.data.type === 'UPDATE_AVAILABLE') {
                        showUpdateNotification();
                    }
                });
                
            } catch (error) {
                console.error('Service Worker registration failed:', error);
            }
        });
    }

    // Show update notification
    function showUpdateNotification() {
        const status = document.getElementById('positionStatus');
        if (status) {
            status.textContent = 'App update available - refresh to update';
            status.className = 'position-status adjust';
            status.style.cursor = 'pointer';
            status.onclick = () => {
                window.location.reload();
            };
            
            // Auto-hide after 10 seconds
            setTimeout(() => {
                status.textContent = 'Align your face with the guides';
                status.className = 'position-status adjust';
                status.style.cursor = 'default';
                status.onclick = null;
            }, 10000);
        }
    }

    // PWA Install Prompt
    let deferredPrompt;
    
    window.addEventListener('beforeinstallprompt', (e) => {
        console.log('PWA install prompt available');
        // Prevent Chrome 67 and earlier from automatically showing the prompt
        e.preventDefault();
        // Stash the event so it can be triggered later
        deferredPrompt = e;
        
        // Show custom install button after 30 seconds
        setTimeout(() => {
            showInstallPrompt();
        }, 30000);
    });

    function showInstallPrompt() {
        if (!deferredPrompt) return;
        
        const status = document.getElementById('positionStatus');
        if (status) {
            status.textContent = 'üì± Tap to install app';
            status.className = 'position-status good';
            status.style.cursor = 'pointer';
            status.onclick = async () => {
                try {
                    // Show the install prompt
                    deferredPrompt.prompt();
                    // Wait for the user to respond to the prompt
                    const { outcome } = await deferredPrompt.userChoice;
                    console.log(`User response to install prompt: ${outcome}`);
                    
                    // Reset the deferred prompt variable
                    deferredPrompt = null;
                    
                    // Reset status
                    status.textContent = 'Align your face with the guides';
                    status.className = 'position-status adjust';
                    status.style.cursor = 'default';
                    status.onclick = null;
                    
                } catch (error) {
                    console.error('Install prompt failed:', error);
                }
            };
            
            // Auto-hide after 10 seconds
            setTimeout(() => {
                if (status.textContent.includes('install')) {
                    status.textContent = 'Align your face with the guides';
                    status.className = 'position-status adjust';
                    status.style.cursor = 'default';
                    status.onclick = null;
                }
            }, 10000);
        }
    }

    // PWA App Installed
    window.addEventListener('appinstalled', (evt) => {
        console.log('PWA was installed');
        // Show success message
        const status = document.getElementById('positionStatus');
        if (status) {
            status.textContent = '‚úÖ App installed successfully!';
            status.className = 'position-status good';
            
            setTimeout(() => {
                status.textContent = 'Align your face with the guides';
                status.className = 'position-status adjust';
            }, 3000);
        }
    });
</script>
</body>
</html>